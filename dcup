#!/bin/bash

# üìç Resolve absolute path to script directory (even if symlinked)
# Get the source of the script: BASH_SOURCE[0] if available, else fallback to $0
SOURCE="${BASH_SOURCE[0]:-$0}"

# Follow symlinks until we reach the real file
while [ -h "$SOURCE" ]; do
  # Get the directory that contains the symlink
  DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
  # Resolve the symlink target
  SOURCE="$(readlink "$SOURCE")"
  # If the resolved path is relative, prepend the directory to make it absolute
  [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
REPO_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"  # Final resolved script location

# üîó Load helper functions (e.g. _parse_args, _validate_shell, _find_latest_container)
source "${REPO_DIR}/helpers.sh"

# üîó Load .env for Docker-related environment variables (e.g. IMAGE_PREFIX, DOCKERHUB_NAMESPACE)
if [[ -f "${REPO_DIR}/.env" ]]; then
  # All variables now availble here
  source "${REPO_DIR}/.env"
else
  echo "‚ùå Missing .env file at ${REPO_DIR}/.env"
  exit 1
fi


#############################################
# üîß Run persistent container for a project #
#############################################

# üîß Parse arguments passed to script (e.g. service, tag, shell, project, --port)
# This sets:
#   - SERVICE           ‚Üí e.g. node
#   - IMAGE_TAG         ‚Üí e.g. latest or v0.01
#   - REQUESTED_SHELL   ‚Üí zsh, bash, sh
#   - PROJECT_NAME      ‚Üí optional override for docker-compose project name
#   - USER_PORTS        ‚Üí array of any --port mappings
_parse_args "$@" || exit $?

# üèó Construct full image tag, e.g. javierfraga/utilcntr-node:latest
image="${DOCKERHUB_NAMESPACE}/${IMAGE_PREFIX}-${SERVICE}:${IMAGE_TAG}"

# üåç Export image name for use in docker-compose.yaml as ${FULL_IMAGE_TAG}
export FULL_IMAGE_TAG="${image}"  # üëà Injects into Compose as environment variable

# üìõ Determine Compose project name. Use PROJECT_NAME if set, otherwise fallback to current directory name.
project="${PROJECT_NAME:-$(basename "$PWD")}"

# üåü Auto-detect preferred shell from image (zsh > bash > sh), if one wasn't explicitly provided
if [[ -z "$REQUESTED_SHELL" ]]; then
  for shell in zsh bash sh; do
    if _validate_shell "$image" "$shell"; then
      REQUESTED_SHELL="$shell"
      break
    fi
  done

  # ‚ùå If no shell found in image, exit with error
  if [[ -z "$REQUESTED_SHELL" ]]; then
    echo "‚ùå No supported shell found in image: $image"
    exit 1
  fi

else
  # ‚úÖ Validate explicitly requested shell exists in image
  _validate_shell "$image" "$REQUESTED_SHELL" || {
    echo "‚ùå Shell '$REQUESTED_SHELL' not found in image: $image"
    exit 1
  }
fi

# üì¶ Handle dynamic port overrides (e.g., --port 3000:80 --port 9229:9229)
if [[ "${#USER_PORTS[@]}" -gt 0 ]]; then
  # Join the array into a comma-separated string for Compose (e.g., 3000:80,9229:9229)
  # IFS (internal field separator) temporarily set to comma
  PORT_MAPPINGS=$(IFS=, ; echo "${USER_PORTS[*]}")
  export PORT_MAPPINGS  # Used inside docker-compose.yaml
  echo "üí° Overriding ports for service '$SERVICE':"
  for p in "${USER_PORTS[@]}"; do
    echo "  - $p"
  done
fi

# üóÇ Set the current host working directory to mount into container at runtime
export HOST_WORKDIR="$(pwd)"

# üß± Run the container with Docker Compose
echo "üîß Starting: $image (project: $project)"
echo "üîß Starting: In this location: $HOST_WORKDIR"

docker compose \
  --file "${REPO_DIR}/docker-compose.yaml" \   # Use your custom Compose file
  --project-name "$project" \                  # Set custom project name (so container is prefixed)
  up \                                         # Start containers
  --detach \                                   # Run in background
  "${SERVICE}"                                 # Only run this service

# üîç Find the name of the most recent container started for this service
container=$(_find_latest_container "$SERVICE") || exit 1

# üõ† Attach an interactive shell to the container after it's started
echo "üõ†  Attaching to container: $container"
docker exec \
  --interactive \                   # Keep STDIN open
  --tty \                           # Allocate a TTY (for shell)
  "$container" "$REQUESTED_SHELL"   # Run container with chosen shell

