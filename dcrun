#!/bin/bash

# üìç Resolve absolute path to script directory (even if symlinked)
# Get the source of the script: BASH_SOURCE[0] if available, else fallback to $0
SOURCE="${BASH_SOURCE[0]:-$0}"

# Follow symlinks until we reach the real file
while [ -h "$SOURCE" ]; do
  # Get the directory that contains the symlink
  DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
  # Resolve the symlink target
  SOURCE="$(readlink "$SOURCE")"
  # If the resolved path is relative, prepend the directory to make it absolute
  [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
REPO_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"  # Final resolved script location

# üîó Load helper functions (e.g., _parse_args, _validate_shell)
source "${REPO_DIR}/helpers.sh"

# üîó Load environment variables from .env (e.g., IMAGE_PREFIX, DOCKERHUB_NAMESPACE)
if [[ -f "${REPO_DIR}/.env" ]]; then
  # All variables now availble here
  source "${REPO_DIR}/.env"
else
  echo "‚ùå Missing .env file at ${REPO_DIR}/.env"
  exit 1
fi

#############################################
# üîß Run ephemeral container for a project  #
#############################################

# üöÄ Parse positional args and --port values into structured variables
# Sets: SERVICE, IMAGE_TAG, REQUESTED_SHELL, USER_PORTS, etc.
# üîß Parse arguments passed to script (e.g. service, tag, shell, project, --port)
# This sets:
#   - SERVICE           ‚Üí e.g. node
#   - IMAGE_TAG         ‚Üí e.g. latest or v0.01
#   - REQUESTED_SHELL   ‚Üí zsh, bash, sh
#   - PROJECT_NAME      ‚Üí optional override for docker-compose project name
#   - USER_PORTS        ‚Üí array of any --port mappings
_parse_args "$@" || exit $?

# üñº Compose full image name from namespace, service, and tag (e.g., javierfraga/utilcntr-node:latest)
image="${DOCKERHUB_NAMESPACE}/${IMAGE_PREFIX}-${SERVICE}:${IMAGE_TAG}"

# üß™ Export the image tag for use in docker-compose.yaml with ${FULL_IMAGE_TAG}
export FULL_IMAGE_TAG="${image}"  # üëà lets Compose use the dynamic image

# üåü If no shell specified, attempt to fall back to preferred shells in order: zsh > bash > sh
if [[ -z "$REQUESTED_SHELL" ]]; then
  for shell in zsh bash sh; do
    if _validate_shell "$image" "$shell"; then
      REQUESTED_SHELL="$shell"
      break
    fi
  done

  # ‚ùå Still no shell found ‚Äî exit with error
  if [[ -z "$REQUESTED_SHELL" ]]; then
    echo "‚ùå No supported shell found in image: $image"
    exit 1
  fi

else
  # ‚úÖ If a shell was requested explicitly, validate that it exists in the image
  _validate_shell "$image" "$REQUESTED_SHELL" || {
    echo "‚ùå Shell '$REQUESTED_SHELL' not found in image: $image"
    exit 1
  }
fi

# üì¶ Handle dynamic port overrides (e.g., --port 3000:80 --port 9229:9229)
if [[ "${#USER_PORTS[@]}" -gt 0 ]]; then
  # Join the array into a comma-separated string for Compose (e.g., 3000:80,9229:9229)
  # IFS (internal field separator) temporarily set to comma
  PORT_MAPPINGS=$(IFS=, ; echo "${USER_PORTS[*]}")
  export PORT_MAPPINGS

  # üì£ Show what was overridden
  echo "üí° Overriding ports for service '$SERVICE':"
  for p in "${USER_PORTS[@]}"; do
    echo "  - $p"
  done
fi

# üíª Store the host path we're running from so Compose can bind-mount it as working_dir
export HOST_WORKDIR="$(pwd)"

echo "üöÄ Running: $image with shell: $REQUESTED_SHELL"
echo "üöÄ Running: In this location: $HOST_WORKDIR"


# üê≥ Run container using docker compose run (ephemeral)
# Use project-wide compose file
#   --file "${REPO_DIR}/docker-compose.yaml" : # Use project-wide compose file
#   --rm : # Delete container after exit
#   --interactive : # Keep STDIN open
#   --tty : # Allocate a TTY (for shell)
#   --service-ports : # Map ports defined in compose (plus overrides)
#   "${SERVICE}" "$REQUESTED_SHELL" : # Run service with chosen shell
docker compose \
  --file "${REPO_DIR}/docker-compose.yaml" \
  run \
  --rm \
  --interactive \
  --tty \
  --service-ports \
  "${SERVICE}" "$REQUESTED_SHELL"
